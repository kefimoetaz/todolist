# Design Document

## Overview

The Dockerized MERN To-Do App is a containerized full-stack application that implements a task management system. The architecture follows a three-tier pattern with clear separation between presentation (React), business logic (Express), and data persistence (MongoDB) layers. Docker Compose orchestrates the containers, managing networking, dependencies, and environment configuration.

The application emphasizes simplicity and maintainability, using RESTful API conventions for client-server communication and standard MongoDB operations for data persistence. All components run in isolated Docker containers to ensure consistent behavior across development and production environments.

## Architecture

### System Components

```
┌─────────────────┐
│  React Frontend │ (Port 3000)
│   (Container)   │
└────────┬────────┘
         │ HTTP/REST
         ▼
┌─────────────────┐
│ Express Backend │ (Port 5000)
│   (Container)   │
└────────┬────────┘
         │ MongoDB Protocol
         ▼
┌─────────────────┐
│    MongoDB      │ (Port 27017)
│   (Container)   │
└─────────────────┘
```

### Container Architecture

- **Frontend Container**: Serves the React application, handles user interactions, and makes API calls to the backend
- **Backend Container**: Runs the Express server, processes API requests, validates data, and communicates with MongoDB
- **Database Container**: Runs MongoDB instance with persistent volume for data storage
- **Docker Network**: Custom bridge network enabling container-to-container communication using service names

### Technology Stack

- **Frontend**: React 18+, Axios for HTTP requests, CSS for styling
- **Backend**: Node.js 18+, Express 4.x, Mongoose for MongoDB ODM, CORS middleware
- **Database**: MongoDB 6.x with persistent volume mounting
- **Containerization**: Docker, Docker Compose for orchestration
- **Testing**: Jest for unit tests, React Testing Library for frontend tests, Supertest for API tests

## Components and Interfaces

### Frontend Components

#### TaskList Component
- Displays all tasks retrieved from the backend
- Handles loading and error states
- Renders individual TaskItem components

#### TaskItem Component
- Displays a single task with description and completion status
- Provides UI controls for editing, deleting, and toggling completion
- Emits events for task operations

#### TaskForm Component
- Provides input field for new task description
- Validates input before submission
- Handles form submission and error display

#### API Service Module
- Centralizes all HTTP requests to the backend
- Handles request/response transformation
- Manages error handling and retry logic

### Backend Components

#### Express Application
- Configures middleware (CORS, JSON parsing, error handling)
- Defines route handlers for CRUD operations
- Manages database connection lifecycle

#### Task Routes
- `POST /api/tasks` - Create new task
- `GET /api/tasks` - Retrieve all tasks
- `PUT /api/tasks/:id` - Update task by ID
- `DELETE /api/tasks/:id` - Delete task by ID

#### Task Controller
- Implements business logic for each CRUD operation
- Validates request data
- Handles error responses with appropriate status codes

#### Task Model (Mongoose Schema)
- Defines task data structure
- Implements validation rules
- Provides database query methods

### API Interface Specification

#### Create Task
```
POST /api/tasks
Content-Type: application/json

Request Body:
{
  "description": "string (required, non-empty)"
}

Success Response (201):
{
  "_id": "string",
  "description": "string",
  "completed": false,
  "createdAt": "ISO8601 timestamp",
  "updatedAt": "ISO8601 timestamp"
}

Error Response (400):
{
  "error": "string"
}
```

#### Get All Tasks
```
GET /api/tasks

Success Response (200):
[
  {
    "_id": "string",
    "description": "string",
    "completed": boolean,
    "createdAt": "ISO8601 timestamp",
    "updatedAt": "ISO8601 timestamp"
  }
]
```

#### Update Task
```
PUT /api/tasks/:id
Content-Type: application/json

Request Body:
{
  "description": "string (optional)",
  "completed": boolean (optional)
}

Success Response (200):
{
  "_id": "string",
  "description": "string",
  "completed": boolean,
  "createdAt": "ISO8601 timestamp",
  "updatedAt": "ISO8601 timestamp"
}

Error Response (404):
{
  "error": "Task not found"
}
```

#### Delete Task
```
DELETE /api/tasks/:id

Success Response (200):
{
  "message": "Task deleted successfully"
}

Error Response (404):
{
  "error": "Task not found"
}
```

## Data Models

### Task Schema

```javascript
{
  _id: ObjectId,           // Auto-generated by MongoDB
  description: String,     // Required, non-empty, trimmed
  completed: Boolean,      // Default: false
  createdAt: Date,        // Auto-generated timestamp
  updatedAt: Date         // Auto-updated timestamp
}
```

### Validation Rules

- `description`: Required, must be non-empty after trimming whitespace, maximum 500 characters
- `completed`: Boolean value, defaults to false if not provided
- `_id`: Auto-generated MongoDB ObjectId, immutable
- Timestamps are automatically managed by Mongoose

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system—essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*


### Property Reflection

After reviewing all testable properties from the prework, several can be consolidated:

- Properties 1.2, 7.1, and 7.4 all test CRUD persistence and can be combined into comprehensive round-trip properties
- Properties 1.4, 3.5, and 4.4 all test UI updates after operations and can be combined into a single UI synchronization property
- Properties 2.2 and 7.3 both test query completeness and are redundant
- Properties 6.1-6.4 test endpoint existence and can be verified through the functional CRUD properties

The consolidated properties below eliminate redundancy while maintaining complete validation coverage.

### Backend API Properties

Property 1: Task creation persistence
*For any* valid task description, when a task is created via the API, the response should contain a unique identifier and the task should be retrievable from the database with all fields intact (description, completed status, timestamps).
**Validates: Requirements 1.2, 7.1**

Property 2: Empty description rejection
*For any* string composed entirely of whitespace characters, attempting to create a task with that description should return a 400 error and no task should be created in the database.
**Validates: Requirements 1.3**

Property 3: Query completeness
*For any* set of tasks in the database, querying all tasks should return exactly those tasks with all their fields.
**Validates: Requirements 2.2, 7.3**

Property 4: Update persistence
*For any* existing task and any valid update (description or completion status), updating the task via the API should return the updated task and the changes should be immediately reflected in the database.
**Validates: Requirements 3.3, 7.4**

Property 5: Delete persistence
*For any* existing task, deleting the task via the API should return success and the task should no longer be retrievable from the database.
**Validates: Requirements 4.2, 7.5**

Property 6: HTTP status code correctness
*For any* API request, the response status code should match the operation result: 201 for creation, 200 for success, 400 for validation errors, 404 for not found, 500 for server errors.
**Validates: Requirements 6.5**

Property 7: Validation error details
*For any* malformed request (missing required fields, invalid data types), the API should return a 400 status with an error message describing the validation failure.
**Validates: Requirements 8.3**

### Frontend Properties

Property 8: Create request formation
*For any* valid task description submitted through the form, the frontend should send a POST request to the backend with the description in the request body.
**Validates: Requirements 1.1**

Property 9: UI synchronization after operations
*For any* successful CRUD operation (create, update, delete), the frontend task list should immediately reflect the change without requiring a manual refresh.
**Validates: Requirements 1.4, 3.5, 4.4**

Property 10: Task rendering completeness
*For any* task retrieved from the backend, the rendered UI should display the task's description and completion status.
**Validates: Requirements 2.3**

Property 11: Update request formation
*For any* task modification (description change or completion toggle), the frontend should send a PUT request with the task ID and the updated fields.
**Validates: Requirements 3.1, 3.2**

Property 12: Delete request formation
*For any* task deletion initiated by the user, the frontend should send a DELETE request with the correct task ID.
**Validates: Requirements 4.1**

Property 13: Error message display
*For any* failed operation (create, update, delete) or network error, the frontend should display a user-friendly error message to the user.
**Validates: Requirements 1.5, 4.5, 8.1, 8.4**

Property 14: State preservation on error
*For any* failed delete operation, the frontend should maintain the current task list without removing the task.
**Validates: Requirements 4.5**

## Error Handling

### Frontend Error Handling

- **Network Errors**: Display "Unable to connect to server. Please check your connection." message
- **API Errors**: Extract and display error message from response body
- **Validation Errors**: Display specific validation messages near the relevant input field
- **Loading States**: Show loading indicators during API calls to provide feedback
- **Retry Logic**: Allow users to retry failed operations without losing input data

### Backend Error Handling

- **Validation Errors**: Return 400 status with descriptive error messages
- **Not Found Errors**: Return 404 status when task ID doesn't exist
- **Database Errors**: Return 500 status with generic error message (log detailed error server-side)
- **Malformed Requests**: Return 400 status with details about invalid fields
- **Unexpected Errors**: Catch all unhandled errors, log them, and return 500 status

### Error Response Format

```javascript
{
  "error": "Human-readable error message",
  "details": "Optional additional context" // Only for validation errors
}
```

## Testing Strategy

### Unit Testing

The application will use a dual testing approach combining unit tests and property-based tests:

**Unit Tests** will cover:
- Specific examples demonstrating correct behavior
- Edge cases like empty task lists, non-existent task IDs
- Error conditions and validation failures
- Component rendering with specific props
- API endpoint integration

**Frontend Unit Tests** (Jest + React Testing Library):
- Component rendering with various props
- User interaction handlers (button clicks, form submissions)
- Error state display
- Empty state display when no tasks exist

**Backend Unit Tests** (Jest + Supertest):
- API endpoint responses for specific inputs
- Database connection on startup
- Error handling for database failures
- Validation of malformed requests

### Property-Based Testing

**Property-based testing library**: fast-check (JavaScript/TypeScript)

Property-based tests will verify universal properties across many randomly generated inputs. Each property test will run a minimum of 100 iterations to ensure thorough coverage.

**Configuration**:
```javascript
fc.assert(
  fc.property(/* generators */, /* test function */),
  { numRuns: 100 }
);
```

**Tagging Convention**:
Each property-based test must include a comment tag referencing the design document:
```javascript
// Feature: dockerized-mern-todo, Property 1: Task creation persistence
```

**Backend Property Tests**:
- Property 1: Task creation persistence (create task, verify in database)
- Property 2: Empty description rejection (generate whitespace strings, verify rejection)
- Property 3: Query completeness (create random task set, verify all returned)
- Property 4: Update persistence (generate updates, verify persistence)
- Property 5: Delete persistence (delete tasks, verify removal)
- Property 6: HTTP status code correctness (various operations, verify status codes)
- Property 7: Validation error details (generate invalid requests, verify error messages)

**Frontend Property Tests**:
- Property 8: Create request formation (generate descriptions, verify API calls)
- Property 9: UI synchronization (perform operations, verify UI updates)
- Property 10: Task rendering completeness (generate tasks, verify all fields rendered)
- Property 11: Update request formation (generate updates, verify API calls)
- Property 12: Delete request formation (trigger deletes, verify API calls)
- Property 13: Error message display (simulate errors, verify messages shown)
- Property 14: State preservation on error (simulate failures, verify state unchanged)

**Generators for Property Tests**:
- Task description generator: random non-empty strings (1-500 chars)
- Whitespace generator: strings of spaces, tabs, newlines
- Task generator: objects with random descriptions and completion status
- Invalid request generator: malformed JSON, missing fields, wrong types
- Task ID generator: valid MongoDB ObjectIds and invalid IDs

### Integration Testing

- End-to-end API tests verifying frontend-backend-database flow
- Docker Compose startup tests ensuring all containers start and connect
- Network connectivity tests between containers

### Test Organization

```
frontend/
  src/
    components/
      __tests__/
        TaskList.test.js
        TaskItem.test.js
        TaskForm.test.js
    services/
      __tests__/
        api.test.js
        api.property.test.js

backend/
  src/
    __tests__/
      api.test.js
      api.property.test.js
    models/
      __tests__/
        Task.test.js
```

## Docker Configuration

### Docker Compose Structure

```yaml
version: '3.8'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://localhost:5000
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "5000:5000"
    environment:
      - MONGODB_URI=mongodb://database:27017/todoapp
      - PORT=5000
    depends_on:
      - database

  database:
    image: mongo:6
    ports:
      - "27017:27017"
    volumes:
      - mongo-data:/data/db

volumes:
  mongo-data:
```

### Container Configuration

**Frontend Dockerfile**:
- Base image: node:18-alpine
- Install dependencies
- Build React app for production
- Serve with lightweight HTTP server

**Backend Dockerfile**:
- Base image: node:18-alpine
- Install dependencies
- Copy source code
- Expose port 5000
- Start Express server

**Database**:
- Use official MongoDB 6 image
- Mount volume for data persistence
- No custom configuration needed

### Environment Variables

**Frontend**:
- `REACT_APP_API_URL`: Backend API base URL

**Backend**:
- `MONGODB_URI`: MongoDB connection string
- `PORT`: Server port (default 5000)
- `NODE_ENV`: Environment (development/production)

## Development Workflow

1. **Local Development**: Run `docker-compose up` to start all containers
2. **Hot Reload**: Frontend and backend support hot reload during development
3. **Testing**: Run tests in each container or locally with `npm test`
4. **Building**: Docker builds are automated through docker-compose
5. **Data Persistence**: MongoDB data persists across container restarts via volume

## Security Considerations

- Input validation on both frontend and backend
- CORS configuration to restrict API access
- Environment variables for sensitive configuration
- No sensitive data in Docker images
- MongoDB authentication (optional enhancement)
- Rate limiting on API endpoints (optional enhancement)

## Performance Considerations

- Minimize API calls by batching operations where possible
- Use React's built-in optimization (memo, useMemo, useCallback)
- Index MongoDB collections for faster queries
- Implement pagination for large task lists (future enhancement)
- Use connection pooling for MongoDB connections

## Future Enhancements

- User authentication and authorization
- Task categories and tags
- Due dates and reminders
- Task priority levels
- Search and filter functionality
- Task sharing between users
- Real-time updates using WebSockets
